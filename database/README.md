# Database
데이터 베이스의 특징은 아래와 같다.
* 실시간 접근성: 데이터베이스는 실시간으로 서비스된다. 사용자가 데이터를 요청하면 수 초 내에 결과를 서비스한다.
* 계속적인 변화: 데이터베이스에 저장된 내용은 한 순간의 상태이지만, 데이터 값은 시간에 따라 항상 바뀐다.
* 동시 공유: 데이터베이스는 서로 다른 업무, 여러 사용자에게 동시에 공유된다.
* 내용에 따른 참조: 데이터베이스에 저장된 데이터는 물리적인 위치가 아니라 값에 따라 참조된다.

스키마는 아래와 같이 정의 할 수 있다.
* 외부 스키마: 사용자가 보게되는 정보에 대한 스키마
* 개념 스키마: 전체 데이터베이스에 대한 정의, 사용자가 다루지 않는 데이터에 대한 스키마를 포함한다. 개념 스키마에 변화가 생겨도 외부 스키마가 직접 다루는 테이블이 아니라면 외부에서 볼 때는 영향이 없다.
* 내부 스키마: 실제 데이터가 저장되는 방식(Type, Size)를 명시한 스키마. 물리적인 Type이나 Size에 변화가 생겨도 개념 스키마에 영향을 끼치지 않는다.

RDB, 관계형 데이터는 행과 열로 표현되는, 테이블형 데이터이다.\
특정 Tuple(Row)를 식별하기 위해서 키를 가지며, 이 키는 반드시 Unique해서 다른 Tuple들과 구분할 수 있어야 한다. 또 키는 Foreign Key처럼 Relation간의 관계를 맺는데도 사용된다. 키를 단일 속성으로 지정할 수 없는 경우 여러 Column을 묶어서 키로 사용할 수 있다.\

Database의 필수적이 조건인 무결성을 유지하기 위해서 다음과 같은 조건이 필요하다.
* 데이터 무결성: 데이터베이스에 저장된 데이터의 일관성을 유지하는 제약
* 도메인 무결성: Relation 내의 Tuple이 각 Domain에 맞는 값만 가지는 제약
* 개체 무결성: 기본키는 NULL이 될 수 없으며, 반드시 Tuple을 구분할 수 있어야 한다.
* 참조 무결성: Foreign Key가 참조하는 / 참조받는 데이터를 삽입, 수정할 때 필요한 제약

---

# Indexing
Database에 저장된 데이터에 접근하는데에는 탐색 시간 + 회전 지연 시간 + 데이터 전송 시간이 필요하다.\
데이터가 많아지면 Query에 시간이 많이 소요되므로 Table에서 한 개 이상의 속성을 이용하여 Index를 설정한다. Binary Tree 형태로 이루어진 Index를 설정하면 검색이 빠르고 효율적으로 레코드를 관리할 수 있다. Index는 WHERE와 JOIN에서 자주 등장하는 속성일 때 효과적이다. 하지만 Table에 Index가 너무 많다면 오히려 Index 추가, 정리 등의 Overhead가 발생해서 효율이 낮아질 수 있다. 따라서 적당한 수의, 가공하지 않는 Domain을 Index로 설정하는 것이 중요하다.\
Index를 선택할 때는 위의 조건들을 이용하여 직접 선택하거나, InnoDB 등의 DB 엔진에서 제공하는 Optimizer를 사용하여 Indexing을 한다.

---

# Transaction
Transaction은 데이터를 다루는 작업의 단위로 All-or-Nothing으로 수행되어야 한다. 이는 Database의 ACID 조건을 충족하기 위함이다.
* Atomicity: Transaction에 포함된 작업은 모두 수행되거나 수행되지 않아야 한다.
* Consistency: Transaction을 수행하기 전과 후에 DB는 상태를 유지해야 한다. Transaction과 관계 없는 값에 대한 변경이 있으면 안된다.
* Isolation: 수행 중인 Transaction에 다른 Transaction이 끼어들어 값을 바꾸면 안된다.
* Durability: 수행을 마친 Transaction의 값은 영구적으로 저장되어야 한다.

Transaction의 All-or-Nothing이라는 조건을 위해서 Rollback을 지원하기도 한다.

---

# ORM (Object-Relation Mapping)
SQL 언어를 직접 사용하지 않도록 객체와 DB를 매칭시켜서 사용할 수 있도록 돕는 프레임워크

---
