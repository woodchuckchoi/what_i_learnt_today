# Deadlock
프로세스의 집합이 더 이상 진행되지 못하고 영구적으로 블록된 상태이다.\
서로 다른 프로세스가 서로 충돌되는 자원을 요구할 때 발생한다.\
Deadlock(교착)이 생기는 조건은 다음과 같다.
* 상호 배제: 한 번에 한 프로세스만 어떠한 자원을 사용할 수 있다.
* 점유 대기: 이미 자원을 가지고 있는 프로세스가 다른 자원을 요청할 수 있다.
* 비선점: 프로세스에 의해 점유된 자원을 뺏을 수 없다.
* 환형 대기: 어떠한 자원을 점유한 프로세스가 해당 자원을 필요로 하는 다른 프로세스가 점유하고 있는 자원을 필요로 한다.

Deadlock의 해결 방안은
* 예방: 위의 4가지 Deadlock이 생기는 이유 중 하나를 시스템에서 허용하지 않는다.
	* 상호 배제는 데이터의 일관성을 위해서 예방할 수 없다.
	* 점유 대기는 어떤 프로세스가 필요로 하는 모든 리소스를 프로세스 시작 시에 한번에 요청하는 방식으로 해결할 수 있다. 다만 지금 사용할 리소스가 아닌 모든 리소스를 요청하므로, 해당 프로세스가 진행되는 동안 다른 프로세스가 자원을 사용할 수 없다는 단점이 있다.
	* 비선점은 어떤 프로세스가 필요로 하는 자원이 사용 중이라면 기존에 점유하던 자원을 반납하고 기다리거나, 다른 프로세스의 자원을 뺏는 방식으로 해결 할 수 있다.
	* 환형 대기는 자원에 프로세스 별 할당 순위를 주어 해결 가능하다.
* 회피: 자원 할당 단계에서 교착이 발생하지 않도록 동적으로 자원을 관리한다.
* 발견: Deadlock이 발견되었을 때, 프로세스를 중지시키고 Rollback하여 해결한다.

---

# Sephamore & Mutex
여러 프로세스나 스레드가 공유 자원에 접근하는 것을 제어하기 위한 수단이다.\
범용 Semaphore의 경우 Pool의 크기를 의미하는 Value가 양수이면 Resource를 할당하고, 음수이면 대기 Queue에 할당한다.\
이진 Semaphore는 뮤텍스와 흡사하게 Boolean Value라고 볼 수 있는 Lock을 설정했다, 해제했다 하며 자원을 관리한다. 차이는 Semaphore는 현재 Resource를 사용 중이지 않은 다른 프로세스가 Semaphore를 제어할 수 있지만, Mutex는 Resource를 가지고 Task를 수행중인 대상만이 Mutex를 제어할 수 있다는 점이다.

---

# Short Circuit Evaluation
C의 &와 &&처럼 같은 값이 나오는 연산일지라도 논리 연산자는 논리 연산에 최적화되어 AND 연산일 때, 앞의 값이 false라면 뒤의 값을 계산하지 않는다. 따라서 논리 연산이 필요한 곳에는 항상 논리 연산을 사용하자. 이것은 ||(OR)에도 마찬가지로 적용되어 앞의 값이 true라면 뒤의 값에 대한 연산을 하지 않는다. 따라서 조건문의 조건절에서 연산을 하도록 프로그래밍 할 때는 주의하자.

---

# Switch의 작동 방식
switch는 jump table을 생성하여, 이에 대한 Index를 기준으로 해당 조건문에 접근한다. 이 jump table은 case의 값에 따라 만들어 지게된다. case가 1~10의 값을 받는다면 jump table에는 0부터 9까지 값이 들어가서 주소 역할을 하는 것과 같다. (아마도 주소 역할을 하기 때문에 정수가 아닌 숫자가 들어갈 수도 없는 것 같다. 0X12FA1244.5 같은 주소는 없으니까..?)  그렇기 때문에 C에서는 switch에 변수를 사용할 수 없다. (미리 jump table이 만들어지는데, 값을 알 수 없는 변수가 들어가면 안되므로)\
if - else만큼 CMP를 수행하는 것과 다르게 jump table의 크기만 커질 뿐 O(1)의 성능으로 switch는 작동하기 때문에 case의 값의 크기가 작고, 정렬되어 있으며, 값 사이의 차이가 크지 않다면 효율적으로 switch를 사용할 수 있다.

---


